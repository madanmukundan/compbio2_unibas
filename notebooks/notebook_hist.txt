 2/1:
# Imports block
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from IPython.display import Markdown as md
from datetime import datetime, timedelta
from statsmodels.nonparametric.smoothers_lowess import lowess

# add cgmparser to module search path for notebook
import os, sys
sys.path.append('..')
import src.cgmquantify as cgm_qf
import src.CGMparser as CGMparser
 2/2:
# Imports block
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from IPython.display import Markdown as md
from datetime import datetime, timedelta
from statsmodels.nonparametric.smoothers_lowess import lowess

# add cgmparser to module search path for notebook
import os, sys
sys.path.append('..')
import src.cgmquantify as cgm_qf
import src.CGMparser as CGMparser
 3/1:
# Imports block
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from IPython.display import Markdown as md
from datetime import datetime, timedelta
from statsmodels.nonparametric.smoothers_lowess import lowess

# add cgmparser to module search path for notebook
import os, sys
sys.path.append('..')
import src.cgmquantify as cgm_qf
import src.CGMparser as CGMparser
 4/1:
# Imports block
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from IPython.display import Markdown as md
from datetime import datetime, timedelta
from statsmodels.nonparametric.smoothers_lowess import lowess

# add cgmparser to module search path for notebook
import os, sys
sys.path.append('..')
import src.cgmquantify as cgm_qf
import src.CGMparser as CGMparser
 4/2:
# Read in FreeStyle Libre Data using CGMParser
cgm_parser = CGMparser('../dist/RupeshKumar_glucose_6-4-2024.csv')
cgm_df = cgm_parser.cgm_df
pt_info = cgm_parser.pt_info
 7/1:
# Imports block
import pandas as pd
import numpy as np
import polars as pl

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib import colormaps

# ice-cream!
# from icecream import ic

# Bokeh for plotting low level
from bokeh.plotting import figure, show
from bokeh.io import output_file, output_notebook
from bokeh.models import DatetimeTickFormatter

from IPython.display import Markdown as md
from datetime import datetime, timedelta
from statsmodels.nonparametric.smoothers_lowess import lowess

# add cgmparser to module search path for notebook
import os, sys
sys.path.append('..')
import src.cgmquantify as cgm_qf
from src.CGMparser import CGMparser
from src.CGMplotter import CGMplotter
 8/1:
# Imports block
import pandas as pd
import numpy as np
import polars as pl

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib import colormaps

# ice-cream!
# from icecream import ic

# Bokeh for plotting low level
from bokeh.plotting import figure, show
from bokeh.io import output_file, output_notebook
from bokeh.models import DatetimeTickFormatter

from IPython.display import Markdown as md
from datetime import datetime, timedelta
from statsmodels.nonparametric.smoothers_lowess import lowess

# add cgmparser to module search path for notebook
import os, sys
sys.path.append('..')
import src.cgmquantify as cgm_qf
from src.CGMparser import CGMparser
from src.CGMplotter import CGMplotter
 8/2:
# Read in FreeStyle Libre Data using CGMParser
cgm_parser = CGMparser('../dist/RupeshKumar_glucose_6-4-2024.csv')
cgm_df = cgm_parser.cgm_df
cgm_info = cgm_parser.cgm_info
 8/3:
# Report Data Source
# Use html tags, no need to end (creates extra lb's)
md(f"<h1> Patient: {cgm_info["Patient Name"]}<br>" +
   f"<h3> CGM Data obtained from: {' '.join(cgm_df["Device"].unique())}<br>" +
   f"<h3> CGM Data date range: {cgm_df["Device Timestamp"].min().date()} to {cgm_df["Device Timestamp"].max().date()}"
)
 8/4:
# Pull out glucose subsetted data and str,datetime,str labels for time
glu_df, weeks, days, day_label = CGMplotter.getFreestyle_glu_df(cgm_df)
# Pull out meals subsetted data
meal_df = CGMplotter.getFreestyle_meal_df(cgm_df, glu_df)
# Report week
md(f"<div><h4><ins>Glucose Data Dates</ins></h4>Weeks Recorded: {', '.join(weeks)}<br>Number of Days: {days.size}</div>")
 8/5:
# 18 g/mol glucose
convert_mgdL_to_mmolL = lambda x: x/18.01559
 8/6: # MAGE, eA1c, LGBI, HGBI, TIR (all ranges)
 8/7:
# Calculate week range and day range for plotting, accomodating for missed weeks
# pd doesn't like to deal with weeks, will convert them to str if month and day info is lost
week_range = pd.date_range(start=days[0],end=days[-1],freq="W",inclusive='both')
week_range = week_range.strftime("%Y-%W")
# print(week_range,week_range.size)

day_range = pd.date_range(start=days[0],end=days[-1],freq="D",inclusive='both').date
# day_range = day_range.strftime("%Y-%M-%D")
# print(day_range,day_range.size)
 8/8:
# NOTE CHECK AND SET Set time range for all below analysis sections

# comment and uncomment out to select week or day range
# str_time_range = "Week"
# plt_time_range = week_range

str_time_range = "Day"
plt_time_range = day_range

# for limiting the xlim to focus if plotting by days days, as int
# this option is ignored if plt_time_range is "Day"
# 0 to 70
min_day = 15
max_day = 42

# min and max range full days
# min_day = 0
# max_day = len(days) - 1

# if week, set range to max
if str_time_range == "Week":
    min_day = 0
    max_day = len(days) - 1

print(f"Plotting from Days {days[min_day]} to {days[max_day]}")
 8/9:
# Plot Daily glucose levels for range of days, with meals indicated and color by TIR

# for scalebar
day_idx = min_day
# day_idx = 15 # for these date, range 0:64

# Set number of days to plot, 7 = 1 week
# num_days = 14
num_days = max_day - min_day

# Extract day data of interest
# day_idx = np.arange(0,5,1)
day_idxs = np.arange(day_idx,day_idx+num_days,1)

# Set plot colors
# colors = plt.cm.jet(np.linspace(0,1, day_idxs.size ))
# colors = plt.cm.jet( np.linspace(0,1,5) )

# Set units label and ylim for glucose plots
glu_units_label = "mg/dL" # now in cgm_info["Units"]
glu_y_lim = [50,230]

# Plot Historic Glucose mg/dL for a given week
# support for overlaid plots
glu_f, axs = plt.subplots(1,1,figsize=[13,5])


# NOTE Time in Range (TIR)
# COLORING - ranges set manually
BR_L2, BR_L1, AR_L1, AR_L2 = 54, 70, 180, 250 
c_to_f = np.vectorize(lambda x: 0.1 if x < BR_L2 else
                                0.25 if x < BR_L1 else
                                0.48 if x < AR_L1 else
                                0.9 if x < AR_L2 else
                                1)


# can do this all in one go rather than loop
for c_i, d_i in enumerate(day_idxs):
    plot_glu_df = glu_df.loc[glu_df.index.date==days[d_i]]

    # plot_time = plot_df["Time"].dt.time.apply(lambda x: x.isoformat(timespec="minutes"))
    # plot_time.reset_index(drop=True,inplace=True)
    plot_time = plot_glu_df.index

    # get colormap for day
    c = c_to_f(plot_glu_df["Glucose"])

    axs.plot(plot_time, plot_glu_df["Glucose"],
            color='#cccccc',
            alpha=0.2,
            linewidth=2,
            linestyle='--',
            label='_nolegend_'
            )

    # Blood glucose readings, unsmoothed
    # axs.plot(plot_time, plot_glu_df["Glucose"], color=colors[c_i])
    axs.scatter(plot_time, plot_glu_df["Glucose"], 
                 s=10,
                 c=c,
                 cmap='jet',
                 vmin=0,
                 vmax=1,
                 label='_nolegend_'
                 )
    
    # Plot meals as little carrot
    plot_meal_df = meal_df.loc[meal_df.index.date==days[d_i]]
    axs.scatter(plot_meal_df.index,plot_meal_df["Nearest Glucose"]+5,
                color="#000000", marker="v", s=40)

# Set plot labels and title (top of first subplot)
# axs[0].title.set_text(f'Days: {', '.join(day_label[day_idxs])} Glucose')
# axs[0].set_xlabel(f"Unsmoothed Glucose {glu_units_label}")
axs.title.set_text(f'Dates: {' to '.join((day_label[day_idxs[0]], day_label[day_idxs[-1]]))} Glucose')
axs.set_xlabel(f"Unsmoothed Glucose {glu_units_label}")
axs.set_ylim(glu_y_lim)

# ax.set_xlim()

axs.legend(["PT Reported Meal"],
            loc='upper right')
8/10:
# Time in Range Line plot and Bar plot, over weeks or days

TIR_plot_dict = {k: np.full((plt_time_range.size,),np.nan) for k in ["TBR_L2", "TBR_L1", "TIR", "TAR_L1", "TAR_L2"] }

for time_idx, time_value in enumerate(plt_time_range):
    time_df = glu_df.loc[glu_df[str_time_range]==time_value]
    if time_df.empty: continue
    time_df.reset_index(drop=True,inplace=True)
    tir_single_timept = cgm_qf.TIR(time_df)
    for k, v in tir_single_timept.items():
        TIR_plot_dict[k][time_idx] = v*100 # mod for percentage for plot as data is decimal

# TIR per week - plot
TIR_lin_fig = plt.figure(figsize=(15,5))
plt.plot(plt_time_range, TIR_plot_dict["TIR"][:], marker='^')
plt.xlabel(str_time_range + "s")
plt.ylabel("TIR [%]")
plt.title("TIR Values Over Time (Crude)")

# NOTE Day range is upcast to full py datetime
if str_time_range == "Day":
    day_min = datetime(year=days[min_day].year,month=days[min_day].month,day=days[min_day].day) - timedelta(days=1) + timedelta(hours=12)
    day_max = datetime(year=days[max_day].year,month=days[max_day].month,day=days[max_day].day) + timedelta(hours=12)
    plt.xlim( ( day_min, day_max ) )

# NOTE Time in Range (TIR)
# COLORING - ranges set manually, should match above
plot_colors = np.array( [0.1, 0.25, 0.48, 0.9,1])
color_idx = 0 # for lack of better idea for ease
cmap = colormaps.get_cmap('jet')

TIR_fig = plt.figure(figsize=(15,5))
bottom = np.zeros(plt_time_range.size,)
bar_wid = 0.7
for lbl, tir in TIR_plot_dict.items():
    plt.bar(plt_time_range, tir, bar_wid, label=lbl, bottom=bottom, facecolor=cmap(plot_colors[color_idx]), edgecolor='k')
    bottom += tir
    color_idx += 1
plt.ylim((-10, 110))
plt.title("Time in Range [%]")
plt.ylabel("Time in Range [%]")
plt.xlabel(str_time_range + "s")

# NOTE choose range to present here or leave commented out for all
if str_time_range == "Day":
    plt.xlim( ( day_min, day_max ) )
8/11:
# eA1c by day or week

eA1c_per_time = np.full((plt_time_range.size,),np.nan)

for time_idx, time_value in enumerate(plt_time_range):
    time_df = glu_df.loc[glu_df[str_time_range]==time_value]
    if time_df.empty: continue
    time_df.reset_index(drop=True,inplace=True)
    eA1c_per_time[time_idx] = cgm_qf.eA1c(time_df)

# eA1c per week - plot
eA1c_fig = plt.figure(figsize=(15,5))
plt.plot(plt_time_range, eA1c_per_time, marker='^')
plt.xlabel(str_time_range+"s")
plt.ylabel("eA1c")
plt.title("eA1c Values Over Time (Crude)")

# NOTE Day range is upcast to full py datetime
day_min = datetime(year=days[min_day].year,month=days[min_day].month,day=days[min_day].day) - timedelta(days=1) + timedelta(hours=12)
day_max = datetime(year=days[max_day].year,month=days[max_day].month,day=days[max_day].day) + timedelta(hours=12)
if str_time_range == "Day":
    plt.xlim( ( day_min, day_max ) )
8/12:
# LGBI per week - calculate and plot
LBGI_per_week = np.full((plt_time_range.size,),np.nan)

for time_idx, time_value in enumerate(plt_time_range):
    time_df = glu_df.loc[glu_df[str_time_range]==time_value]
    if time_df.empty: continue
    time_df.reset_index(drop=True,inplace=True)
    LBGI_per_week[time_idx] = cgm_qf.LBGI(time_df)

# LGBI per week - plot
LGBI_fig = plt.figure(figsize=(13,5))
plt.plot(plt_time_range, LBGI_per_week, marker='o',color='b')
plt.xlabel(str_time_range)
plt.ylabel("LBGI (mg/dL)")
plt.title("LGBI Values Over Time (Crude)")

# NOTE Day range is upcast to full py datetime
day_min = datetime(year=days[min_day].year,month=days[min_day].month,day=days[min_day].day) - timedelta(days=1) + timedelta(hours=12)
day_max = datetime(year=days[max_day].year,month=days[max_day].month,day=days[max_day].day) + timedelta(hours=12)
if str_time_range == "Day":
    plt.xlim( ( day_min, day_max ) )
8/13:
# HGBI per week - calculate
HBGI_per_week = np.full((plt_time_range.size,),np.nan)

for time_idx, time_value in enumerate(plt_time_range):
    time_df = glu_df.loc[glu_df[str_time_range]==time_value]
    if time_df.empty: continue
    time_df.reset_index(drop=True,inplace=True)
    HBGI_per_week[time_idx] = cgm_qf.HBGI(time_df)

# HGBI per week - plot
HGBI_fig = plt.figure(figsize=(13,5))
plt.plot(plt_time_range, HBGI_per_week, marker='o',color='r')
plt.xlabel(str_time_range)
plt.ylabel("HBGI (mg/dL)")
plt.title("HGBI Values Over Time (Crude)")

# NOTE Day range is upcast to full py datetime
day_min = datetime(year=days[min_day].year,month=days[min_day].month,day=days[min_day].day) - timedelta(days=1) + timedelta(hours=12)
day_max = datetime(year=days[max_day].year,month=days[max_day].month,day=days[max_day].day) + timedelta(hours=12)
if str_time_range == "Day":
    plt.xlim( ( day_min, day_max ) )
8/14:
# MAGE - calculate, will potentially take a long time to run if many days
mage_over_time = np.full((plt_time_range.size,),np.nan)

for time_idx, time_value in enumerate(plt_time_range):
    time_df = glu_df.loc[glu_df[str_time_range]==time_value]
    if time_df.empty: continue
    time_df.reset_index(inplace=True)
    mage_over_time[time_idx] = cgm_qf.MAGE(time_df)

# MAGE - plot
mage_fig = plt.figure(figsize=(13,5))
plt.plot(plt_time_range, mage_over_time, marker='o')
plt.xlabel(str_time_range)
plt.ylabel("MAGE (mg/dL)")
plt.title(f"MAGE per {str_time_range} (mg/dL)")

# NOTE Day range is upcast to full py datetime
day_min = datetime(year=days[min_day].year,month=days[min_day].month,day=days[min_day].day) - timedelta(days=1) + timedelta(hours=12)
day_max = datetime(year=days[max_day].year,month=days[max_day].month,day=days[max_day].day) + timedelta(hours=12)
if str_time_range == "Day":
    plt.xlim( ( day_min, day_max ) )
 9/1: "A" * "3"
 9/2: print("Welcome to Python!")
 9/3: "A" * "3"
 9/4:
#example
result = multiplyMaxByTwo([1,2,5,3,2])
print(result)
#[1,2,10,3,2]
 9/5:
def multiplyMaxByTwo(my_list):
    temp_max = my_list[0]
    temp_idx = 0
    for i,v in enumerate(my_list):
        if v > temp_max: temp_idx, temp_max = i, v
    my_list[temp_idx] = temp_max*2
    return my_list
 9/6:
#example
result = multiplyMaxByTwo([1,2,5,3,2])
print(result)
#[1,2,10,3,2]
11/1: a = [1,2,3,4,5]
11/2: a[a==max(a)]=max(a)*2
11/3: a
 9/7:
def multiplyMaxByTwo(my_list):
    return [e for e in my_list if e==max(my_list) else e*2]
11/4: import timeit
 9/8:
def multiplyMaxByTwo(my_list):
    return [e if e!=max(my_list) else e*2 for e in my_list]
 9/9:
#example
result = multiplyMaxByTwo([1,2,5,3,2])
print(result)
#[1,2,10,3,2]
13/1: import timeit
13/2: timeit.timeit([e if e!=max(my_list) else e*2 for e in my_list],number=100)
13/3: my_list = [1:5]
13/4: my_list = [1,2,3,4,5]
13/5: timeit.timeit([e if e!=max(my_list) else e*2 for e in my_list],number=100)
13/6: timeit.timeit(('[e if e!=max(my_list) else e*2 for e in my_list]'),number=100)
13/7: my_list = [1,2,3,4,5]
13/8: timeit.timeit(('[e if e!=max(my_list) else e*2 for e in my_list]'),number=100)
13/9: timeit.timeit(lambda: [e if e!=max(my_list) else e*2 for e in my_list]),setup='my_list=[1,2,3,4,5]',number=100)
13/10: timeit.timeit(lambda: [e if e!=max(my_list) else e*2 for e in my_list],setup='my_list=[1,2,3,4,5]',number=100)
13/11: timeit.timeit(lambda: [e if e!=me_max else e*2 for e in my_list],setup='my_list=[1,2,3,4,5]; me_max=max(my_list)',number=100)
13/12: timeit.timeit(lambda: [e if e!=me_max else e*2 for e in my_list],setup='my_list=[1,2,3,4,5]; me_max=max(my_list;)',number=100)
13/13: timeit.timeit(lambda: [e if e!=me_max else e*2 for e in my_list],setup='my_list=[1,2,3,4,5]; me_max=max(my_list);',number=100)
9/10:
def deleteMin(my_list):
    return [e for e in my_list if e!=min(my_list)]
9/11:
#example
result = deleteMin([1,2,5,3,2])
print(result)
#[2,5,3,2]
9/12:
def sumLists(my_list1,my_list2):
    return [a+b for a in my_list1 for b in my_list2]
9/13:
#example
result = sumLists([1,2,3],[4,5,6])
print(result)
[5,7,9]
9/14:
def sumLists(my_list1,my_list2):
    return [a+b for a in my_list1 for b in my_list2]
9/15:
#example
result = sumLists([1,2,3],[4,5,6])
print(result)
[5,7,9]
9/16:
def sumLists(my_list1,my_list2):
    if len(my_list1)!=len(my_list2): raise ValueError("Input lists must have the same size.")
    for i, v in enumerate(my_list1):
    return
9/17:
def sumLists(my_list1,my_list2):
    if len(my_list1)!=len(my_list2): raise ValueError("Input lists must have the same size.")
    return [my_list1[i]+my_list2[i] for i in enumerate(my_list1)]
9/18:
#example
result = sumLists([1,2,3],[4,5,6])
print(result)
[5,7,9]
9/19:
def sumLists(my_list1,my_list2):
    if len(my_list1)!=len(my_list2): raise ValueError("Input lists must have the same size.")
    return [my_list1[i]+my_list2[i] for i, _ in enumerate(my_list1)]
9/20:
#example
result = sumLists([1,2,3],[4,5,6])
print(result)
[5,7,9]
9/21:
def reverseList(my_list):
    return my_list[::-1]
9/22:
#example
result = reverseList([1,2,3,4,5,6])
print(result)
[6,5,4,3,2,1]
9/23:
def evenNumbers(my_list):
    return [e for e in my_list if e%2==0]
9/24:
#example
result = evenNumbers([1,2,3,4,5,6])
print(result)
[2,4,6]
9/25:
def computeStatistics(my_list):
    return [min(my_list), max(my_list), sum(my_list), sum(my_list)/len(my_list)]
9/26:
#example
result = computeStatistics([1,2,3,4,5,6])
print(result)
[1,6,21,3.5]
15/1: import string
15/2: string.digits
15/3: a = [1,2,3,4,5]
15/4: a[:3]
16/1:
import pandas as pd
from dnasurvey.ResponseViewer import SurveyApp
16/2: print(os.path.pwd())
16/3:
import pandas as pd
import os
16/4: print(os.path.pwd())
16/5: print(os.pwd())
16/6: print(os.getcwd())
16/7: from dnasurvey.ResponseViewer import SurveyApp
16/8:
sys.path.append(os.path.join(os.getcwd(),"..","dnasurvey"))
from dnasurvey.ResponseViewer import SurveyApp
16/9:
import pandas as pd
import os
import sys
16/10:
sys.path.append(os.path.join(os.getcwd(),"..","dnasurvey"))
from dnasurvey.ResponseViewer import SurveyApp
17/1:
import pandas as pd
import os
import sys
17/2:
sys.path.append(os.path.join(os.getcwd(),"..","dnasurvey"))
from dnasurvey.ResponseViewer import SurveyApp
18/1:
import pandas as pd
import os
import sys
18/2:
sys.path.append(os.path.join(os.getcwd(),"..","dnasurvey"))
from dnasurvey.ResponseViewer import SurveyApp
18/3:
sys.path.append(os.path.join(os.getcwd(),"..","dnasurvey"))
from dnasurvey.ResponseViewer import SurveyApp
18/4:
sys.path.append(os.path.join(os.getcwd(),"..","dnasurvey"))
from dnasurvey.ResponseViewer import SurveyApp
18/5:
sys.path.append(os.path.join(os.getcwd(),"..","dnasurvey"))
from dnasurvey.ResponseViewer import SurveyApp
18/6:
sys.path.append(os.path.join(os.getcwd(),"..","dnasurvey"))
from dnasurvey.ResponseViewer import SurveyApp
19/1:
import pandas as pd
import os
import sys
19/2:
sys.path.append(os.path.join(os.getcwd(),"..","dnasurvey"))
from dnasurvey.ResponseViewer import SurveyApp
19/3:
sys.path.append(os.path.join(os.getcwd(),"..","dnasurvey"))
from dnasurvey.ResponseViewer import SurveyApp
19/4:
sys.path.append(os.path.join(os.getcwd(),".."))
from dnasurvey.ResponseViewer import SurveyApp
19/5:
sys.path.append(os.path.join(os.getcwd(),".."))
from dnasurvey.ResponseViewer import SurveyApp
19/6: os.path.join(os.getcwd(),"..")
19/7:
sys.path.append(os.path.basename(os.getcwd()))
from dnasurvey.ResponseViewer import SurveyApp
19/8:
sys.path.append(os.path.basename(os.getcwd()))
from dnasurvey.ResponseViewer import SurveyApp
19/9: os.path.basename(os.getcwd())
19/10: os.path.dirname(os.getcwd())
19/11:
sys.path.append(os.path.dirname(os.getcwd()))
from dnasurvey.ResponseViewer import SurveyApp
19/12:
sys.path.append(os.path.dirname(os.getcwd()))
from DNAsurvey.ResponseViewer import SurveyApp
19/13:
sys.path.append(os.path.dirname(os.getcwd()))
from DNASurvey.ResponseViewer import SurveyApp
19/14:
sys.path.append(os.path.dirname(os.getcwd()))
from dnasurvey.DNASurvey.ResponseViewer import SurveyApp
19/15:
sys.path.append(os.path.join(os.path.dirname(os.getcwd())))
from dnasurvey.ResponseViewer import SurveyApp
19/16:
sys.path.append(os.path.join(os.path.dirname(os.getcwd())))
from dnasurvey.ResponseViewer import SurveyApp
20/1:
import pandas as pd
import os
import sys
20/2:
sys.path.append(os.path.join(os.path.dirname(os.getcwd())))
from dnasurvey.ResponseViewer import SurveyApp
20/3: df = pd.read_excel("/home/madan/code/dna_survey/Questions/MALINI 3 21 MBTI Proofed_250227_UsedForInitialTesting.xlsx")
20/4:
df = pd.read_excel("/home/madan/code/dna_survey/Questions/MALINI 3 21 MBTI Proofed_250227_UsedForInitialTesting.xlsx",
                   usecols="B")
20/5: df.iloc([300,1])
20/6: df.iloc((300,1))
20/7: df.iloc[300,1]
20/8: df.iloc[300,0]
20/9: df.dropna()
22/1:
import pandas as pd
import os
import sys
22/2:
sys.path.append(os.path.join(os.path.dirname(os.getcwd())))
from dnasurvey.DNASurvey import DNASurveyApp
22/3:
sys.path.append(os.path.join(os.path.dirname(os.getcwd())))
from dnasurvey import DNASurveyApp
22/4:
import pandas as pd
import os
import sys
22/5:
sys.path.append(os.path.join(os.path.dirname(os.getcwd())))
from dnasurvey import DNASurveyApp
22/6:
sys.path.append(os.path.join(os.path.dirname(os.getcwd())))
from dnasurvey import DNASurvey, StartPage, SurveyPage, ResultPage
22/7:
sys.path.append(os.path.join(os.path.dirname(os.getcwd())))
from dnasurvey import StartPage, SurveyPage, ResultPage, DNASurvey
22/8:
sys.path.append(os.path.join(os.path.dirname(os.getcwd())))
from dnasurvey import StartPage, SurveyPage, ResultPage
22/9:
sys.path.append(os.path.join(os.path.dirname(os.getcwd())))
from dnasurvey import StartPage, ResultPage
22/10:
sys.path.append(os.path.join(os.path.dirname(os.getcwd())))
from dnasurvey import StartPage
22/11:
sys.path.append(os.path.join(os.path.dirname(os.getcwd())))
from dnasurvey import StartPage, QuestionPage, StartPage, ThankYouPage, DNASurvey
22/12:
sys.path.append(os.path.join(os.path.dirname(os.getcwd())))
from dnasurvey import StartPage, QuestionPage, StartPage, ThankYouPage, DNASurveyApp
22/13:
sys.path.append(os.path.join(os.path.dirname(os.getcwd())))
from dnasurvey import StartPage, QuestionPage, StartPage, ThankYouPage, DNASurvey
22/14:
sys.path.append(os.path.join(os.path.dirname(os.getcwd()),"dnasurvey"))
import StartPage, QuestionPage, StartPage, ThankYouPage, DNASurvey
23/1:
import pandas as pd
import os
import sys
23/2:
sys.path.append(os.path.join(os.path.dirname(os.getcwd()),"dnasurvey"))
import StartPage, QuestionPage, StartPage, ThankYouPage, DNASurvey
23/3:
sys.path.append(os.path.join(os.path.dirname(os.getcwd()),"dnasurvey"))
import StartPage, QuestionPage, ThankYouPage, DNASurvey
23/4: os.path.dirname(os.getcwd())
25/1:
import pandas as pd
import os
import sys
25/2:
sys.path.append(os.path.join(os.path.dirname(os.getcwd()),"dnasurvey"))
import StartPage, QuestionPage, ThankYouPage, DNASurvey
26/1:
import pandas as pd
import os
import sys
26/2:
sys.path.append(os.path.join(os.path.dirname(os.getcwd()),"dnasurvey"))
import StartPage, QuestionPage, ThankYouPage, DNASurvey
26/3: os.path.dirname(os.getcwd())
26/4:
df = pd.read_excel("/home/madan/code/dna_survey/Questions/MALINI 3 21 MBTI Proofed_250227_UsedForInitialTesting.xlsx",
                   usecols="B")
27/1:
import pandas as pd
import os
import sys
27/2:
sys.path.append(os.path.join(os.path.dirname(os.getcwd()),"dnasurvey"))
import StartPage, QuestionPage, ThankYouPage, DNASurvey
27/3: os.path.dirname(os.getcwd())
27/4:
df = pd.read_excel("/home/madan/code/dna_survey/Questions/Questions.xlsx",
                   usecols="B")
27/5: /home/madan/code/dna_survey/Responses/Bill_Survey_responses.xlsx
28/1:
import pandas as pd
import os
import sys
28/2:
sys.path.append(os.path.join(os.path.dirname(os.getcwd()),"dnasurvey"))
import StartPage, QuestionPage, ThankYouPage, DNASurvey
28/3: os.path.dirname(os.getcwd())
28/4:
df = pd.read_excel("/home/madan/code/dna_survey/Questions/Questions.xlsx",
                   usecols="B")
28/5: /home/madan/code/dna_survey/Responses/Bill_Survey_responses.xlsx
28/6: df["Response"].index("<missing>")
28/7: df["Response"].loc("<missing>")
28/8: df.index(df["Response"] == "<missing>")
28/9: df.index[df["Response"] == "<missing>"]
28/10: df = pd.read_excel("/home/madan/code/dna_survey/Responses/Jimmy_Survey_89shf9_responses.xlsx"))
28/11: df = pd.read_excel("/home/madan/code/dna_survey/Responses/Jimmy_Survey_89shf9_responses.xlsx")
28/12: df.index[df["Response"] == "<missing>"]
28/13: df.index[df["Response"] == "<missing>"][0]
28/14: df.index[df["Response"] == "<missing>"]
28/15: df.index[df["Response"] == "<missing>"](1)
28/16: df.index[df["Response"] == "<missing>"][0]
28/17: print(df.index[df["Response"] == "<missing>"][0])
29/1:
import pandas as pd
import os
import sys
29/2:
sys.path.append(os.path.join(os.path.dirname(os.getcwd()),"dnasurvey"))
import StartPage, QuestionPage, ThankYouPage, DNASurvey
29/3: os.path.dirname(os.getcwd())
29/4: df = pd.read_excel("/home/madan/code/dna_survey/Responses/Jimmy_Survey_89shf9_responses.xlsx")
29/5: print(df.index[df["Response"] == "<missing>"][0])
29/6: df.index[df["Response"]=='<missing>']
30/1:
import pandas as pd
import os
import sys
30/2:
sys.path.append(os.path.join(os.path.dirname(os.getcwd()),"dnasurvey"))
import StartPage, QuestionPage, ThankYouPage, DNASurvey
30/3: os.path.dirname(os.getcwd())
30/4: df = pd.read_excel("/home/madan/code/dna_survey/Responses/Jimmy_Survey_89shf9_responses.xlsx")
30/5: print(df.index[df["Response"] == "<missing>"][0])
30/6: df.index[df["Response"]=='<missing>']
30/7:
import pandas as pd
import os
import random
import sys
30/8:
import pandas as pd
import os
import random
import sys
30/9:
sys.path.append(os.path.join(os.path.dirname(os.getcwd()),"dnasurvey"))
import StartPage, QuestionPage, ThankYouPage, DNASurvey
30/10: os.path.dirname(os.getcwd())
30/11: df = pd.read_excel("/home/madan/code/dna_survey/Responses/Jimmy_Survey_89shf9_responses.xlsx")
30/12: print(df.index[df["Response"] == "<missing>"][0])
30/13:
a = list(range(0,90))
a = random.shuffle(a)
30/14: df.index[df["Response"]=='<missing>']
30/15:
a = list(range(0,90))
a = random.shuffle(a)
print(a[:5])
30/16:
a = list(range(0,90))
a = random.shuffle(a)
# print(a[:5])
30/17:
a = list(range(0,90))
a = random.shuffle(a)
# print(a[:5])
a
30/18:
a = list(range(90))
a = random.shuffle(a)
# print(a[:5])
30/19: df.index[df["Response"]=='<missing>']
30/20:
a = list(range(90))
a = random.shuffle(a)
print(a[:5])
30/21:
a = list(range(90))
# a = random.shuffle(a)
print(a[:5])
30/22:
a = list(range(90))
random.shuffle(a)
print(a[:5])
30/23: np.intersect(b,a)
31/1:
import pandas as pd
import os
import random
import sys
import numpy as np
31/2:
sys.path.append(os.path.join(os.path.dirname(os.getcwd()),"dnasurvey"))
import StartPage, QuestionPage, ThankYouPage, DNASurvey
31/3: os.path.dirname(os.getcwd())
31/4: df = pd.read_excel("/home/madan/code/dna_survey/Responses/Jimmy_Survey_89shf9_responses.xlsx")
31/5: print(df.index[df["Response"] == "<missing>"][0])
31/6:
a = list(range(90))
random.shuffle(a)
print(a[:5])
31/7: b = df.index[df["Response"]=='<missing>']
31/8: np.intersect(b,a)
31/9: np.intersection(b,a)
31/10: np.intersect1d(b,a)
31/11:
a = list(range(90))
random.shuffle(a)
print(a[:5])
31/12: print(a[:5])
31/13: print(a[:5])
31/14: np.intersect1d(b,a)
31/15: np.intersect1d(a,b)
31/16: np.intersect1d(a,b, return_indices=True)
32/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
from population_dynamics.population import Population
from population_dynamics.individual import Individual
32/2:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), '..'))
from population_dynamics.population import Population
from population_dynamics.individual import Individual
32/3: os.path.join(os.path.dirname(os.getcwd())
32/4:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), '..'))
from population_dynamics.population import Population
from population_dynamics.individual import Individual
32/5: os.path.join(os.path.dirname(os.getcwd()), '..')
32/6:
import os, sys
sys.path.append(os.path.dirname(os.getcwd()))
from population_dynamics.population import Population
from population_dynamics.individual import Individual
32/7:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population
from individual import Individual
32/8:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population
from individual import Individual
33/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population
from individual import Individual
33/2: os.path.join(os.path.dirname(os.getcwd()), '..')
33/3:
my_pop = Population(initial_size=10,genome_length=500, mutation_rate=0)
print(my_pop)
33/4:
my_pop = Population(initial_size=10,genome_length=500, mutation_rate=0)
print(str(my_pop))
34/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # warning is ok, jupyter import bug
from individual import Individual
34/2:
my_pop = Population(initial_size=10,genome_length=500, mutation_rate=0)
print(str(my_pop))
36/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # warning is ok, jupyter import bug
from individual import Individual
36/2:
my_pop = Population(initial_size=10,genome_length=500, mutation_rate=0)
print(str(my_pop))
37/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # warning is ok, jupyter import bug
from individual import Individual
37/2:
my_pop = Population(initial_size=10,genome_length=500, mutation_rate=0)
print(str(my_pop))
37/3:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # warning is ok, jupyter import bug
from individual import Individual
37/4:
my_pop = Population(initial_size=10,genome_length=500, mutation_rate=0)
print(str(my_pop))
37/5:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # warning is ok, jupyter import bug
from individual import Individual
37/6:
my_pop = Population(initial_size=10,genome_length=500, mutation_rate=0)
print(str(my_pop))
37/7:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # warning is ok, jupyter import bug
from individual import Individual
37/8:
my_pop = Population(initial_size=10,genome_length=500, mutation_rate=0)
print(str(my_pop))
37/9:
# Evolve population in iterative steps
number_of_generations = 1
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
37/10:
# Evolve population in iterative steps
number_of_generations = 50
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
37/11:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.print_ancestor_trace(my_pop.individuals[individual_index])
37/12:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_trace()
37/13:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
38/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
38/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
38/3:
# Evolve population in iterative steps
number_of_generations = 50
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
38/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
38/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1

# Find common ancestor
common_ancestor = my_pop.find_common_ancestor(individual_index_1, individual_index_2)
print("Individuals " + str(individual_index_1) + " and " + str(individual_index_2) + " share a common ancestor " + str(common_ancestor) + " generations ago")
38/6:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1

# Find common ancestor
common_ancestor = my_pop.find_most_recent_common_ancestor(individual_index_1, individual_index_2)
print("Individuals " + str(individual_index_1) + " and " + str(individual_index_2) + " share a common ancestor " + str(common_ancestor) + " generations ago")
38/7:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1

# Find common ancestor
common_ancestor = my_pop.find_most_recent_common_ancestor(my_pop.individuals[individual_index_1], my_pop.individuals[individual_index_2])
print("Individuals " + str(individual_index_1) + " and " + str(individual_index_2) + " share a common ancestor " + str(common_ancestor) + " generations ago")
38/8:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1

# Find common ancestor
common_ancestor = my_pop.find_most_recent_common_ancestor((my_pop.individuals[individual_index_1], my_pop.individuals[individual_index_2]))
print("Individuals " + str(individual_index_1) + " and " + str(individual_index_2) + " share a common ancestor " + str(common_ancestor) + " generations ago")
38/9:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1

# Find common ancestor
common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))
print("Individuals " + str(individual_index_1) + " and " + str(individual_index_2) + " share a common ancestor " + str(common_ancestor) + " generations ago")
38/10:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1
current_generation = len(my_pop.generations) - 1

# Find common ancestor
common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))
print(f"Individuals {str(individual_index_1)} and"+
      f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1} share a common ancestor + str(common_ancestor) + th generation"))
38/11:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1
current_generation = len(my_pop.generations) - 1

# Find common ancestor
common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))
print(f"Individuals {str(individual_index_1)} and"+
      f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1} share a common ancestor str(common_ancestor) + th generation")
38/12:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1
current_generation = len(my_pop.generations) - 1

# Find common ancestor
common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))
print(f"Individuals {str(individual_index_1)} and "+
      f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
      f"share a common ancestor: {str(common_ancestor)} + th generation")
38/13:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1
current_generation = len(my_pop.generations) - 1

# Find common ancestor
common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        f"share a common ancestor: {str(common_ancestor)}th generation")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
39/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
39/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
39/3:
# Evolve population in iterative steps
number_of_generations = 50
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
39/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
39/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1
current_generation = len(my_pop.generations) - 1

# Find common ancestor
common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        f"share a common ancestor: {str(common_ancestor)}th generation")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
39/6:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1
current_generation = len(my_pop.generations) - 1

# Find common ancestor
common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor: {str(common_ancestor)}th generation")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
40/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
40/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
40/3:
# Evolve population in iterative steps
number_of_generations = 50
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
40/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
40/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1
current_generation = len(my_pop.generations) - 1

# Find common ancestor
common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor: {repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
40/6:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
40/7:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
40/8:
# Evolve population in iterative steps
number_of_generations = 50
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
40/9:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
40/10:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1
current_generation = len(my_pop.generations) - 1

# Find common ancestor
common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor: {repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
41/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
41/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
41/3:
# Evolve population in iterative steps
number_of_generations = 50
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
41/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
41/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1
current_generation = len(my_pop.generations) - 1

# Find common ancestor
common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor: {repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
41/6:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor: {repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
42/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
42/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
42/3:
# Evolve population in iterative steps
number_of_generations = 50
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
42/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
42/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor: {repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
43/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
43/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
43/3:
# Evolve population in iterative steps
number_of_generations = 50
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
43/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
43/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
43/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
44/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
44/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
44/3:
# Evolve population in iterative steps
number_of_generations = 50
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
44/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
44/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
44/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
44/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 1
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
44/8:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 1
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}")
44/9:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 1
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}"+
      f"{repr(my_pop.individuals[individual_index_1])}\n{repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
44/10:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 1
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
45/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
45/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
45/3:
# Evolve population in iterative steps
number_of_generations = 50
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
45/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
45/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 1
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
45/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
45/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 1
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
46/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
46/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
46/3:
# Evolve population in iterative steps
number_of_generations = 50
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
46/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
46/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
46/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
46/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
47/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
47/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
47/3:
# Evolve population in iterative steps
number_of_generations = 50
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
47/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
47/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
47/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
47/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
47/8:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
48/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
48/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
48/3:
# Evolve population in iterative steps
number_of_generations = 10
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
48/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
48/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
49/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
49/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
49/3:
# Evolve population in iterative steps
number_of_generations = 10
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
49/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
49/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
50/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
50/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
50/3:
# Evolve population in iterative steps
number_of_generations = 10
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
50/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
50/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
51/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
51/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
51/3:
# Evolve population in iterative steps
number_of_generations = 20
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
51/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
51/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
51/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
52/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
52/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
52/3:
# Evolve population in iterative steps
number_of_generations = 20
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
52/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
52/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
52/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
53/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
53/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
53/3:
# Evolve population in iterative steps
number_of_generations = 20
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
53/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
53/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
56/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
56/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
56/3:
# Evolve population in iterative steps
number_of_generations = 20
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
56/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
56/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
57/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
57/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
57/3:
# Evolve population in iterative steps
number_of_generations = 25
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
57/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
57/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
57/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
58/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
58/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
58/3:
# Evolve population in iterative steps
number_of_generations = 25
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
58/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
58/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
58/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
58/7:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
60/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
60/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
60/3:
# Evolve population in iterative steps
number_of_generations = 25
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
60/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
60/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
60/6:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
a, b, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
60/7:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
# _, _, common_ancestor = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

# Find common ancestor
a, b = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
62/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
62/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
62/3:
# Evolve population in iterative steps
number_of_generations = 25
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
62/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
62/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
62/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
65/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
65/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
65/3:
# Evolve population in iterative steps
number_of_generations = 25
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
65/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
65/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
65/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
67/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
67/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
67/3:
# Evolve population in iterative steps
number_of_generations = 25
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
67/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
67/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
67/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
69/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
69/2:
# Set population parameters and initialize
initial_size = 30
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
69/3:
# Evolve population in iterative steps
number_of_generations = 25
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
69/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
69/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
69/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
69/7:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
69/8:
# Set population parameters and initialize
initial_size = 20
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
69/9:
# Evolve population in iterative steps
number_of_generations = 30
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
69/10:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
69/11:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
69/12:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
69/13:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
69/14:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
72/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
72/2:
# Set population parameters and initialize
initial_size = 20
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
72/3:
# Evolve population in iterative steps
number_of_generations = 30
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
72/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
72/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
72/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
74/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
74/2:
# Set population parameters and initialize
initial_size = 20
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
74/3:
# Evolve population in iterative steps
number_of_generations = 30
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
74/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
74/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
74/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
75/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
75/2:
# Set population parameters and initialize
initial_size = 20
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
75/3:
# Evolve population in iterative steps
number_of_generations = 30
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
75/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
75/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
75/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
75/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
75/8:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
77/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
77/2:
# Set population parameters and initialize
initial_size = 20
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
77/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
77/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
77/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
77/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
77/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
77/8:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
78/1:
# Define population sizes to analyze
sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)

for size, avg_time in results.items():
    print(f"Population Size {len(size)}: Average TMRCA = {avg_time:.2f} generations\n")
79/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
79/2:
# Set population parameters and initialize
initial_size = 20
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
79/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
79/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
79/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
79/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
79/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
79/8:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
79/9:
# Define population sizes to analyze
sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)

for size, avg_time in results.items():
    print(f"Population Size {len(size)}: Average TMRCA = {avg_time:.2f} generations\n")
80/1:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [5, 5, 10, 10, 20, 20, 30, 30, 40, 40, 50, 50, 60, 60, 70, 70, 80, 80, 90, 90, 100, 100]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)

for size, avg_time in results.items():
    print(f"Population Size {len(size)}: Average TMRCA = {avg_time:.2f} generations\n")
81/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
81/2:
# Set population parameters and initialize
initial_size = 20
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
81/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
81/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
81/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
81/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
81/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
81/8:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
81/9:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [5, 5, 10, 10, 20, 20, 30, 30, 40, 40, 50, 50, 60, 60, 70, 70, 80, 80, 90, 90, 100, 100]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)

for size, avg_time in results.items():
    print(f"Population Size {len(size)}: Average TMRCA = {avg_time:.2f} generations\n")
81/10:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
sizes = [50, 100, 200, 300, 400, 500]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)

for size, avg_time in results.items():
    print(f"Population Size {len(size)}: Average TMRCA = {avg_time:.2f} generations\n")
83/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
83/2:
# Set population parameters and initialize
initial_size = 20
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
83/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
83/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
83/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
83/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
83/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
83/8:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
83/9:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(1,100,10)]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)

for size, avg_time in results.items():
    print(f"Population Size {len(size)}: Average TMRCA = {avg_time:.2f} generations\n")
84/1: print([i for i in range(1,100,10)])
85/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
85/2:
# Set population parameters and initialize
initial_size = 20
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
85/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
85/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
85/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
85/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
85/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
85/8:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
85/9:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(1,100,10)]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)

for size, avg_time in results.items():
    print(f"Population Size {len(size)}: Average TMRCA = {avg_time:.2f} generations\n")
86/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
86/2:
# Set population parameters and initialize
initial_size = 20
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
86/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
86/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
86/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
86/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
86/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
86/8:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
86/9:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(1,100,10)]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)

for size, avg_time in results.items():
    print(f"Population Size {len(size)}: Average TMRCA = {avg_time:.2f} generations\n")
87/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
87/2:
# Set population parameters and initialize
initial_size = 20
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
87/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
87/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
87/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
87/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
87/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
87/8:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
87/9:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(1,100,10)]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)

for size, avg_time in results.items():
    print(f"Population Size {len(size)}: Average TMRCA = {avg_time:.2f} generations\n")
89/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
89/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
89/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
89/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
89/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
89/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
89/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
89/8:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
89/9:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(1,100,10)]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)

for size, avg_time in results.items():
    print(f"Population Size {len(size)}: Average TMRCA = {avg_time:.2f} generations\n")
89/10:
for size, avg_time in results.items():
    print(f"Population Size {size}: Average TMRCA = {avg_time:.2f} generations\n")
89/11:
# Plot MRCA
# Create figure and axis
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(results.keys())
times = [results[size] for size in sizes]

ax.plot(sizes, times, 'o-', color='blue')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title('Relationship Between Population Size and Time to MRCA')
ax.grid(True)
89/12:
# Plot MRCA
# Create figure and axis
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(results.keys())
times = [results[size] for size in sizes]

ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, 100], [0,100], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title('Relationship Between Population Size and Time to MRCA')
ax.grid(True)
90/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
90/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
90/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
90/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
90/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
90/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
90/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
90/8:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
90/9:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(1,100,10)]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)
90/10:
for size, avg_time in results.items():
    print(f"Population Size {size}: Average TMRCA = {avg_time:.2f} generations\n")
90/11:
# Plot MRCA
# Create figure and axis
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(results.keys())
times = [results[size] for size in sizes]

ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, 100], [0,100], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title('Relationship Between Population Size and Time to MRCA')
ax.grid(True)
91/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
91/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0.01

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
91/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
91/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
91/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
91/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
91/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
91/8:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
91/9:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(1,100,10)]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)
91/10:
for size, avg_time in results.items():
    print(f"Population Size {size}: Average TMRCA = {avg_time:.2f} generations\n")
91/11:
# Plot MRCA
# Create figure and axis
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(results.keys())
times = [results[size] for size in sizes]

ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, 100], [0,100], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title('Relationship Between Population Size and Time to MRCA')
ax.grid(True)
92/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
92/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0.01

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
92/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
92/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
92/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
92/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
92/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
92/8:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
92/9:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(1,100,10)]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)
92/10:
for size, avg_time in results.items():
    print(f"Population Size {size}: Average TMRCA = {avg_time:.2f} generations\n")
92/11:
# Plot MRCA
# Create figure and axis
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(results.keys())
times = [results[size] for size in sizes]

ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, 100], [0,100], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title('Relationship Between Population Size and Time to MRCA')
ax.grid(True)
93/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
93/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0.01

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
93/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
93/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
93/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
93/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
93/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
93/8:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
93/9:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(1,500,100)]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)
84/2: sizes = ([i, i] for i in range(1,400,100))
84/3: sizes
84/4: sizes = [[i, i] for i in range(1,400,100)]
84/5: sizes
94/1:
# Plot MRCA
# Create figure and axis
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(results.keys())
times = [results[size] for size in sizes]

ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, 100], [0,100], '--', color='cyan')
ax.plot([0, 100], [0,200], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title('Relationship Between Population Size and Time to MRCA')
ax.grid(True)
ax.legend(["TMRCA", "1X", "2X"], loc='upper left')
plt.show()
95/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
95/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0.01

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
95/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
95/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
95/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
95/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
95/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
95/8:
import networkx as nx

import matplotlib.pyplot as plt

# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
95/9:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = ([i, i] for i in range(1,200,50))

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)
95/10:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [[i, i] for i in range(1,200,50)]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)
84/6: a - [i, i for i in range(0,10)]
84/7: a = [i, i for i in range(0,10)]
84/8: a = [i, a for i in range(0,10) for a in range(0,10)]
95/11:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(1,200,50)]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)
98/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
import networkx as nx
import matplotlib.pyplot as plt
98/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0.01

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
98/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
98/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
98/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
98/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
98/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
98/8:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
98/9:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges only for chosen individual(s) in current generation
# individual_idxs = [0, 8]
individual_idxs = 0
for individual in my_pop.individuals[individual_idxs]:
    if hasattr(individual, 'parent'):
        while individual.parent is not None:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
98/10:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges only for chosen individual(s) in current generation
# individual_idxs = [0, 8]
individual_idxs = 0
for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
98/11:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges only for chosen individual(s) in current generation
# individual_idxs = [0, 8]
individual_idxs = [0]
for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
98/12:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(1,80,10)]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)
100/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
import networkx as nx
import matplotlib.pyplot as plt
100/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 500
mutation_rate = 0.01

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
100/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
100/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
100/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
100/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
100/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
100/8:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
100/9:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges only for chosen individual(s) in current generation
individual_idxs = [0, 8]
# individual_idxs = [0]
for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
100/10:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(1,80,10)]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=3)
100/11:
for size, avg_time in results.items():
    print(f"Population Size {size}: Average TMRCA = {avg_time:.2f} generations\n")
100/12:
# Plot MRCA
# Create figure and axis
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(results.keys())
times = [results[size] for size in sizes]

ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, 100], [0,100], '--', color='cyan')
ax.plot([0, 100], [0,200], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title('Relationship Between Population Size and Time to MRCA')
ax.grid(True)
ax.legend(["TMRCA", "1X", "2X"], loc='upper left')
plt.show()
101/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
import networkx as nx
import matplotlib.pyplot as plt
101/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 50
mutation_rate = 0.01

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
101/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
101/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
101/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
101/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
101/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
101/8:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
101/9:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges only for chosen individual(s) in current generation
individual_idxs = [0, 8]
# individual_idxs = [0]
for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
101/10:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(1,200,50)]

# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=5)
101/11:
for size, avg_time in results.items():
    print(f"Population Size {size}: Average TMRCA = {avg_time:.2f} generations\n")
101/12:
# Plot MRCA
# Create figure and axis
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(results.keys())
times = [results[size] for size in sizes]

ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, 100], [0,100], '--', color='cyan')
ax.plot([0, 100], [0,200], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title('Relationship Between Population Size and Time to MRCA')
ax.grid(True)
ax.legend(["TMRCA", "1X", "2X"], loc='upper left')
plt.show()
101/13:
# Plot MRCA
# Create figure and axis
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(results.keys())
times = [results[size] for size in sizes]

ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, 500], [0,500], '--', color='cyan')
ax.plot([0, 500], [0,1000], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title('Relationship Between Population Size and Time to MRCA')
ax.grid(True)
ax.legend(["TMRCA", "1X", "2X"], loc='upper left')
plt.show()
101/14:
# Plot MRCA
# Create figure and axis
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(results.keys())
times = [results[size] for size in sizes]
max_size = max(sizes)
offset = 20

ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, max_size+offset], [0,max_size+offset], '--', color='cyan')
ax.plot([0, max_size+offset], [0,max_size*2+2*offset], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title('Relationship Between Population Size and Time to MRCA')
ax.grid(True)
ax.legend(["TMRCA", "1X", "2X"], loc='upper left')
plt.show()
101/15:
# Plot MRCA
# Create figure and axis
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(results.keys())
times = [results[size] for size in sizes]
max_size = max(sizes)
offset = round(max_size/10)

ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, max_size+offset], [0,max_size+offset], '--', color='cyan')
ax.plot([0, max_size+offset], [0,max_size*2+2*offset], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title('Relationship Between Population Size and Time to MRCA')
ax.grid(True)
ax.legend(["TMRCA", "1X", "2X"], loc='upper left')
plt.show()
101/16:
# Plot MRCA
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(results.keys())
times = [results[size] for size in sizes]
max_size = max(sizes)
offset = round(max_size/10)

# Plot 1x and 2x line, simulation results
ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, max_size+offset], [0,max_size+offset], '--', color='cyan')
ax.plot([0, max_size+offset], [0,max_size*2+2*offset], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title(f'Relationship Between Population Size and Time to MRCA {simulation_reps:0.0f} Repetitions')
ax.grid(True)
ax.legend(["TMRCA", "1X", "2X"], loc='upper left')
plt.show()
102/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
import networkx as nx
import matplotlib.pyplot as plt
102/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 50
mutation_rate = 0.01

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
102/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
102/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
102/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
102/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
102/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
102/8:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
102/9:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges only for chosen individual(s) in current generation
individual_idxs = [0, 8]
# individual_idxs = [0]
for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
102/10:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(1,300,50)]
simulation_reps = 5
# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=simulation_reps)
102/11:
for size, avg_time in results.items():
    print(f"Population Size {size}: Average TMRCA = {avg_time:.2f} generations\n")
102/12:
# Plot MRCA
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(results.keys())
times = [results[size] for size in sizes]
max_size = max(sizes)
offset = round(max_size/10)

# Plot 1x and 2x line, simulation results
ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, max_size+offset], [0,max_size+offset], '--', color='cyan')
ax.plot([0, max_size+offset], [0,max_size*2+2*offset], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title(f'Relationship Between Population Size and Time to MRCA {simulation_reps:0.0f} Repetitions')
ax.grid(True)
ax.legend(["TMRCA", "1X", "2X"], loc='upper left')
plt.show()
103/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
import networkx as nx
import matplotlib.pyplot as plt
103/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 50
mutation_rate = 0.01

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
103/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
103/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
103/5:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
103/6:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges only for chosen individual(s) in current generation
individual_idxs = [0, 8]
# individual_idxs = [0]
for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
103/7:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
103/8:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
103/9:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
103/10:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(1,300,50)]
simulation_reps = 5
# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=simulation_reps)
103/11:
for size, avg_time in results.items():
    print(f"Population Size {size}: Average TMRCA = {avg_time:.2f} generations\n")
103/12:
# Plot MRCA
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(results.keys())
times = [results[size] for size in sizes]
max_size = max(sizes)
offset = round(max_size/10)

# Plot 1x and 2x line, simulation results
ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, max_size+offset], [0,max_size+offset], '--', color='cyan')
ax.plot([0, max_size+offset], [0,max_size*2+2*offset], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title(f'Relationship Between Population Size and Time to MRCA {simulation_reps:0.0f} Repetitions')
ax.grid(True)
ax.legend(["TMRCA", "1X", "2X"], loc='upper left')
plt.show()
104/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
import networkx as nx
import matplotlib.pyplot as plt
104/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 50
mutation_rate = 0.01

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
104/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
104/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
104/5:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
104/6:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges only for chosen individual(s) in current generation
individual_idxs = [0, 8]
# individual_idxs = [0]
for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
104/7:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
104/8:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
104/9:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
104/10:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(5,306,50)]
simulation_reps = 5
# Run analysis
results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=simulation_reps)
104/11:
for size, avg_time in results.items():
    print(f"Population Size {size}: Average TMRCA = {avg_time:.2f} generations\n")
104/12:
# Plot MRCA
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(results.keys())
times = [results[size] for size in sizes]
max_size = max(sizes)
offset = round(max_size/10)

# Plot 1x and 2x line, simulation results
ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, max_size+offset], [0,max_size+offset], '--', color='cyan')
ax.plot([0, max_size+offset], [0,max_size*2+2*offset], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title(f'Relationship Between Population Size and Time to MRCA {simulation_reps:0.0f} Repetitions')
ax.grid(True)
ax.legend(["TMRCA", "1X", "2X"], loc='upper left')
plt.show()
104/13:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(5,50,10)]
simulation_reps = 5
# Run analysis
means, results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=simulation_reps)
105/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
import networkx as nx
import matplotlib.pyplot as plt
105/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 50
mutation_rate = 0.01

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
105/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
105/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
105/5:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
105/6:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges only for chosen individual(s) in current generation
individual_idxs = [0, 8]
# individual_idxs = [0]
for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
105/7:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
105/8:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
105/9:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
105/10:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(5,50,10)]
simulation_reps = 5
# Run analysis
means, results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=simulation_reps)
105/11:
for size, avg_time in means.items():
    print(f"Population Size {size}: Average TMRCA = {avg_time:.2f} generations, all: {results[size]}\n")
105/12:
# Plot MRCA
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(means.keys())
times = [means[size] for size in sizes]
max_size = max(sizes)
offset = round(max_size/10)

# Plot 1x and 2x line, simulation means/results
ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, max_size+offset], [0,max_size+offset], '--', color='cyan')
ax.plot([0, max_size+offset], [0,max_size*2+2*offset], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title(f'Relationship Between Population Size and Time to MRCA {simulation_reps:0.0f} Repetitions')
ax.grid(True)
ax.legend(["TMRCA", "1X", "2X"], loc='upper left')
plt.show()
106/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
import networkx as nx
import matplotlib.pyplot as plt
106/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 50
mutation_rate = 0.01

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
106/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
106/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
106/5:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
106/6:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges only for chosen individual(s) in current generation
individual_idxs = [0, 8]
# individual_idxs = [0]
for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
106/7:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
106/8:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
106/9:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
106/10:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(5,50,10)]
simulation_reps = 50
# Run analysis
means, results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=simulation_reps)
106/11:
for size, avg_time in means.items():
    print(f"Population Size {size}: Average TMRCA = {avg_time:.2f} generations, all: {results[size]}\n")
106/12:
# Plot MRCA
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(means.keys())
times = [means[size] for size in sizes]
max_size = max(sizes)
offset = round(max_size/10)

# Plot 1x and 2x line, simulation means/results
ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, max_size+offset], [0,max_size+offset], '--', color='cyan')
ax.plot([0, max_size+offset], [0,max_size*2+2*offset], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title(f'Relationship Between Population Size and Time to MRCA {simulation_reps:0.0f} Repetitions')
ax.grid(True)
ax.legend(["TMRCA", "1X", "2X"], loc='upper left')
plt.show()
107/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
import networkx as nx
import matplotlib.pyplot as plt
107/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 50
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
107/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
107/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
107/5:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
107/6:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges only for chosen individual(s) in current generation
individual_idxs = [0, 8]
# individual_idxs = [0]
for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
107/7:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
107/8:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
107/9:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
107/10:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(5,50,10)]
simulation_reps = 50
# Run analysis
means, results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=simulation_reps)
107/11:
for size, avg_time in means.items():
    print(f"Population Size {size}: Average TMRCA = {avg_time:.2f} generations, all: {results[size]}\n")
107/12:
# Plot MRCA
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(means.keys())
times = [means[size] for size in sizes]
max_size = max(sizes)
offset = round(max_size/10)

# Plot 1x and 2x line, simulation means/results
ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, max_size+offset], [0,max_size+offset], '--', color='cyan')
ax.plot([0, max_size+offset], [0,max_size*2+2*offset], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title(f'Relationship Between Population Size and Time to MRCA {simulation_reps:0.0f} Repetitions')
ax.grid(True)
ax.legend(["TMRCA", "1X", "2X"], loc='upper left')
plt.show()
108/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
import networkx as nx
import matplotlib.pyplot as plt
108/2:
# Set population parameters and initialize
initial_size = 10
genome_length = 50
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
108/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
108/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
108/5:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
108/6:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges only for chosen individual(s) in current generation
individual_idxs = [0, 8]
# individual_idxs = [0]
for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
108/7:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
108/8:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
108/9:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
108/10:
# Define population sizes to analyze
# sizes = [5, 10, 20, 30, 40, 50, 60, 70, 90, 100, 200, 300, 400, 500]
# sizes = [50, 100, 200, 300, 400, 500]
sizes = [i for i in range(5,50,10)]
simulation_reps = 50
# Run analysis
means, results = my_pop.analyze_population_size_vs_mrca_time(sizes, repetitions=simulation_reps)
108/11:
for size, avg_time in means.items():
    print(f"Population Size {size}: Average TMRCA = {avg_time:.2f} generations, all: {results[size]}\n")
108/12:
# Plot MRCA
fig, ax = plt.subplots(figsize=(10, 4))

sizes = list(means.keys())
times = [means[size] for size in sizes]
max_size = max(sizes)
offset = round(max_size/10)

# Plot 1x and 2x line, simulation means/results
ax.plot(sizes, times, 'o-', color='blue')
ax.plot([0, max_size+offset], [0,max_size+offset], '--', color='cyan')
ax.plot([0, max_size+offset], [0,max_size*2+2*offset], '--', color='cyan')
ax.set_xlabel('Population Size')
ax.set_ylabel('Time to MRCA (generations)')
ax.set_title(f'Relationship Between Population Size and Time to MRCA {simulation_reps:0.0f} Repetitions')
ax.grid(True)
ax.legend(["TMRCA", "1X", "2X"], loc='upper left')
plt.show()
108/13:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges only for chosen individual(s) in current generation
# individual_idxs = [0, 8]
individual_idxs = [i for i in range(len(my_pop.individuals))]
gen_limit = 22
# individual_idxs = [0]
for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None and individual.parent.generation_idx >= gen_limit:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
108/14:
# Create a directed graph
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges only for chosen individual(s) in current generation
# individual_idxs = [0, 8]
individual_idxs = [i for i in range(len(my_pop.individuals))]
gen_limit = 22
# individual_idxs = [0]
for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None and individual.parent.generation >= gen_limit:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
108/15:
# Graph of population to trace most recent common ancestor
G = nx.DiGraph()

# Add edges only for chosen individual(s) in current generation
# individual_idxs = [0, 8]
individual_idxs = [i for i in range(len(my_pop.individuals))]
gen_limit = 22
# individual_idxs = [0]

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in reversed(list(enumerate(my_pop.generations))):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)


for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None and individual.parent.generation >= gen_limit:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
108/16:
# Graph of population to trace most recent common ancestor
G = nx.DiGraph()

# Add edges only for chosen individual(s) in current generation
# individual_idxs = [0, 8]
individual_idxs = [i for i in range(len(my_pop.individuals))]
gen_limit = mrca_individual.generation
# individual_idxs = [0]

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in reversed(list(enumerate(my_pop.generations))):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)


for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None and individual.parent.generation >= gen_limit:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5-gen_idx)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
108/17:
# Graph of population to trace most recent common ancestor
G = nx.DiGraph()

# Add edges only for chosen individual(s) in current generation
# individual_idxs = [0, 8]
individual_idxs = [i for i in range(len(my_pop.individuals))]
gen_limit = mrca_individual.generation
# individual_idxs = [0]

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in reversed(list(enumerate(my_pop.generations))):
    if gen_idx < gen_limit-1:
        break
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)


for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None and individual.parent.generation >= gen_limit:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5-gen_idx)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
108/18:
# Graph of population to trace most recent common ancestor
G = nx.DiGraph()

# Add edges only for chosen individual(s) in current generation
# individual_idxs = [0, 8]
individual_idxs = [i for i in range(len(my_pop.individuals))]
gen_limit = mrca_individual.generation
# individual_idxs = [0]

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in reversed(list(enumerate(my_pop.generations))):
    if gen_idx < gen_limit:
        break
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)


for individual_idx in individual_idxs:
    individual = my_pop.individuals[individual_idx]
    if hasattr(individual, 'parent'):
        while individual.parent is not None and individual.parent.generation >= gen_limit:
            G.add_edge(individual.id, individual.parent.id)
            individual = individual.parent

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5-gen_idx)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
110/1:
import os, sys
sys.path.append(os.path.join(os.path.dirname(os.getcwd()), 'population_dynamics'))
from population import Population  # jupyter import bug, is fine
from individual import Individual  # jupyter import bug, is fine
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
110/2:
# Set population parameters and initialize
initial_size = 20
genome_length = 500
mutation_rate = 0

# Initialize population
my_pop = Population(initial_size, genome_length, mutation_rate)
print(str(my_pop))
110/3:
# Evolve population in iterative steps
number_of_generations = 40
print("Evolving for " + str(number_of_generations) + " generations")
for p_i in range(number_of_generations):
    my_pop.get_next_generation()

print(str(my_pop))
110/4:
# Print ancestor trace of a given individual
individual_index = 0
my_pop.individuals[individual_index].print_ancestor_tree()
110/5:
# Find how many generations ago two individuals shared a common ancestor
individual_index_1 = 0
individual_index_2 = 8
current_generation = len(my_pop.generations) - 1

# Find common ancestor
_, _, common_ancestor = (my_pop.
                   find_most_recent_common_ancestor(
                                                    (my_pop.individuals[individual_index_1],
                                                     my_pop.individuals[individual_index_2])))

# Find common ancestor
# a, b = (my_pop.
#                    find_most_recent_common_ancestor(
#                                                     (my_pop.individuals[individual_index_1],
#                                                      my_pop.individuals[individual_index_2])))

if common_ancestor:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n"+
        f"share a common ancestor:\n{repr(common_ancestor)}")
else:
    print(f"Individuals {str(individual_index_1)} and "+
        f"{str(individual_index_2)} in this Generation #{len(my_pop.generations)-1}\n "+
        "do not share a common ancestor")
110/6:
# Find out how long ago all individuals shared a common ancestor
tmrca, mrca_individual = my_pop.time_to_most_recent_common_ancestor()

print(f"Time to most recent common ancestor: {tmrca} generations\n{repr(mrca_individual)}")
110/7:
# Calculate and report genetic distance between two individuals in current population
individual_index_1 = 0
individual_index_2 = 8
genetic_distance = my_pop.individuals[individual_index_1].get_genetic_distance(
    my_pop.individuals[individual_index_2])
# Similarity as 1 - dissimilarity
genetic_similarity = (1 - genetic_distance/len(my_pop.individuals[individual_index_1].genome))*100
print(f"Genetic distance between individuals {individual_index_1} and {individual_index_2}: {genetic_distance}\n"+
      f"#{individual_index_1} {repr(my_pop.individuals[individual_index_1])}\n"+
      f"#{individual_index_2} {repr(my_pop.individuals[individual_index_2])}\n"+
      f"Genetic similarity: {genetic_similarity:.2f}%")
110/8:
# Create graph of population tree
G = nx.DiGraph()

# Add nodes for all individuals in all generations
positions = {}
for gen_idx, generation in enumerate(my_pop.generations):
    y_pos = -gen_idx  # Negative to have first generation at top
    for ind_idx, individual in enumerate(generation):
        # Use individual's ID as node identifier
        node_id = individual.id
        G.add_node(node_id)
        # Position nodes in a row for each generation
        x_pos = (ind_idx - len(generation)/2) / len(generation)  # Center individuals horizontally
        positions[node_id] = (x_pos, y_pos)

# Add edges (arrows) from individuals to their parents
for gen_idx, generation in enumerate(my_pop.generations[1:], 1):  # Start from second generation
    for individual in generation:
        if hasattr(individual, 'parent') and individual.parent:
            G.add_edge(individual.id, individual.parent.id)

# Create the plot
plt.figure(figsize=(15, 10))
nx.draw(G, pos=positions, 
        node_size=100,
        node_color='lightblue',
        edge_color='gray',
        arrowsize=10,
        with_labels=False)

# Add generation labels on the y-axis
plt.ylim(-(len(my_pop.generations)-0.5), 0.5)
plt.title('Population Tree\n(arrows point from individuals to their ancestors)')
plt.show()
110/9: %history
110/10: %history
   1: %history -g -f "02_FinitePopulationDynamicsSpec.ipynb"
